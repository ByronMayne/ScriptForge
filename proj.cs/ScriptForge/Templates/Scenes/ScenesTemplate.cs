// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace ScriptForge
{
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class ScenesTemplate : ScriptForge.BaseTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write("using System.Collections.ObjectModel;\r\n");
 WriteClassOutline(); 
            return this.GenerationEnvironment.ToString();
        }

    /// <summary>
    /// A function used to define any content that should exist in this classes namespace.
    /// </summary>
    public override void WriteNamespaceContent()
    {
    }

	/// <summary>
    /// This class contains all our GUI Content labels that we use in Script Forge
    /// </summary>
    public override void WriteClassContent()
    {
		// Const elements
		for(int i = 0; i < m_Scenes.Length; i++)
        {
			Write("public const string ");
			Write(m_Scenes[i].ToUpper());
			Write(" = \"");
			Write(m_Scenes[i]);
			WriteLine("\";");
        }

		// Space
		WriteLine("");

		// Array
		WriteLine("// An array containing all the names of our scenes.");
		WriteLine("private static string[] m_Names = new string[]");
		WriteLine("{");
		PushIndent(indent);
		{
			for(int i = 0; i < m_Scenes.Length; i++)
			{
				Write("\"");
				Write(m_Scenes[i]);
				WriteLine("\",");
			}
        }
		PopIndent();
		WriteLine("};");
    }

	/// <summary>
    /// Invoked when the enum should be defined by this widget.
    /// </summary>
    public override void WriteEnumContent()
    {
		if(!m_CreateEnum)
        {
			return;
        }

this.Write("/// <summary>\r\n/// An enum that contains the names of every scene that\r\n/// is in" +
        " your project.\r\n/// </summary>\r\n");


		Write("public enum ");
		WriteLine(m_EnumName);
		WriteLine("{");
		PushIndent(indent);
		for(int i = 0; i < m_Scenes.Length; i++)
        {
			Write(m_Scenes[i]);
			if( i < m_Scenes.Length - 1)
            {
				WriteLine(",");
            }
			else
            {
				WriteLine(string.Empty);
            }
        }
		PopIndent();
		WriteLine("}");
		WriteLine(string.Empty);
    }
	

 
    /// <summary>
    /// Invoked when the helper functions should be defined by this widget.
    /// </summary>
	public override void WriteHelperFunctions()
    {

this.Write("\r\n/// <summary>\t\t\r\n/// Gets a read only version of the array of scene names in th" +
        "e build settings. \r\n/// </summary>\t\t\r\npublic static ReadOnlyCollection<string> N" +
        "ames(string sceneName)\r\n{\t\t\r\n    return new ReadOnlyCollection<string>(m_Names);" +
        "\r\n}\r\n\r\n/// <summary>\t\t\r\n/// This function takes in a string name and returns \t\t\r" +
        "\n/// the scene ID with that name. If the name is invalid\t\t\r\n/// it return -1.\t\t\r" +
        "\n/// </summary>\t\t\r\n/// <returns>The ID of the requested scene name.</returns>\t\t\r" +
        "\n/// <param name=\"sceneName\">A name of the scene you want the ID for.</param>\t\t\r" +
        "\npublic static int SceneNameToID(string sceneName)\r\n{\r\n    for (int i = 0; i < m" +
        "_Names.Length; i++)\r\n    {\r\n\t\tif(m_Names[i].Equals(sceneName, System.StringCompa" +
        "rison.OrdinalIgnoreCase))\r\n        {\r\n\t\t\treturn i;\r\n        }\r\n    }\r\n    //No s" +
        "cene found with that ID.\t\t\r\n    return -1;\r\n}\r\n\r\n/// <summary>\t\t\r\n/// This takes" +
        " a scene ID and returns the name. If\t\t\r\n/// the ID is invalid it returns \'None\'." +
        "\t\t\r\n/// </summary>\t\t\r\n/// <returns>The identifier of the scene.</returns>\t\t\r\n///" +
        " <param name=\"sceneIndex\">An name of the scene with the requested ID</param>\t\t\r\n" +
        "public static string SceneIndexToName(int sceneIndex)\r\n{\r\n    if (sceneIndex >= " +
        "0 && sceneIndex < m_Names.Length)\r\n    {\r\n        return m_Names[sceneIndex];\r\n " +
        "   }\r\n\r\n    return string.Empty;\r\n}\r\n\r\n/// <summary>\t\t\r\n/// Determines if it is " +
        "valid scene name.\t\t\r\n/// </summary>\t\t\r\n/// <returns><c>true</c> if is valid scen" +
        "e name the specified sceneName; otherwise, <c>false</c>.</returns>\t\t\r\n/// <param" +
        " name=\"sceneName\">The name of the scene in build settings.</param>\t\t\r\npublic sta" +
        "tic bool IsValidSceneName(string sceneName)\t\t\r\n{\t\t\r\n\tfor( int i = 0; i < m_Names" +
        ".Length; i++)\t\t\r\n\t{\t\t\r\n\t\tif(m_Names[i].Equals(sceneName, System.StringComparison" +
        ".OrdinalIgnoreCase))\r\n\t\t{\r\n\t\t\treturn true;\t\r\n\t\t}\t\r\n\t}\t\t\r\n\t\t\t\r\n\treturn false;\t\t\r\n" +
        "}\r\n\r\n/// <summary>\t\t\r\n/// Determines if is valid scene ID.\t\t\r\n/// </summary>\t\t\r\n" +
        "/// <returns><c>true</c> if is valid scene I the specified anID; otherwise, <c>f" +
        "alse</c>.</returns>\t\t\r\n/// <param name=\"anID\">An I.</param>\t\t\r\npublic static boo" +
        "l IsValidSceneID(int sceneID)\t\t\r\n{\t\t\r\n\treturn sceneID >= 0 && sceneID < m_Names." +
        "Length;\r\n}\r\n");


    }



private string _m_EnumNameField;

/// <summary>
/// Access the m_EnumName parameter of the template.
/// </summary>
private string m_EnumName
{
    get
    {
        return this._m_EnumNameField;
    }
}

private string[] _m_ScenesField;

/// <summary>
/// Access the m_Scenes parameter of the template.
/// </summary>
private string[] m_Scenes
{
    get
    {
        return this._m_ScenesField;
    }
}

private bool _m_CreateEnumField;

/// <summary>
/// Access the m_CreateEnum parameter of the template.
/// </summary>
private bool m_CreateEnum
{
    get
    {
        return this._m_CreateEnumField;
    }
}


/// <summary>
/// Initialize the template
/// </summary>
public override void Initialize()
{
    base.Initialize();
    if ((this.Errors.HasErrors == false))
    {
bool m_EnumNameValueAcquired = false;
if (this.Session.ContainsKey("m_EnumName"))
{
    this._m_EnumNameField = ((string)(this.Session["m_EnumName"]));
    m_EnumNameValueAcquired = true;
}
if ((m_EnumNameValueAcquired == false))
{
    object data = global::System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("m_EnumName");
    if ((data != null))
    {
        this._m_EnumNameField = ((string)(data));
    }
}
bool m_ScenesValueAcquired = false;
if (this.Session.ContainsKey("m_Scenes"))
{
    this._m_ScenesField = ((string[])(this.Session["m_Scenes"]));
    m_ScenesValueAcquired = true;
}
if ((m_ScenesValueAcquired == false))
{
    object data = global::System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("m_Scenes");
    if ((data != null))
    {
        this._m_ScenesField = ((string[])(data));
    }
}
bool m_CreateEnumValueAcquired = false;
if (this.Session.ContainsKey("m_CreateEnum"))
{
    this._m_CreateEnumField = ((bool)(this.Session["m_CreateEnum"]));
    m_CreateEnumValueAcquired = true;
}
if ((m_CreateEnumValueAcquired == false))
{
    object data = global::System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("m_CreateEnum");
    if ((data != null))
    {
        this._m_CreateEnumField = ((bool)(data));
    }
}


    }
}


    }
}
